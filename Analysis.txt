Task 0
----------
- This task is achieved by array access.
- The complexity is O(1).

Task 1
----------
- get_column function circulates an array once and it's O(n).
- get_unique converts a list to a set object. This conversion iterates over each
element and adds it to a hash map. Therefore the average and worst-case complexities
are O(n) and O(n**2), respectively. Since hash-collusions almost never happen, we can
safely assume O(n).
- get_unique_multi initially collects all numbers using a nested loop. 
The looped variables are irrelevant to the complexity. It, then, calls
get_column and get_unique subsequently. Subsequent calls do not increase
the complexity asymptotically. Therefore it's O(n).

All in all, the task scales linearly w.r.t the size of the records. 


Task 2
----------
- get_column is O(n) (See Task 1).
- get_argmax function converts the numbers from string to int by circulating the array
and type-casting each element. Therefore, it's O(n).
- We have another list comprehension (in line 35) which involves a forward pass and access, therefore, O(n).
- print statement is array access, therefore, O(1).

-- All in all, it's O(n).


Task 3
----------
PART A:
- get_unique is O(n) (See Task 2).
- get_column is O(n) (See Task 1).
- get_prefix_type determines a number's prefix type that can be either fixed, mobile or telemarket.
  the complexities are O(n), O(1) and O(1) for fixed, mobile and telemarket checks, respectively.

- get_mobile_prefix runs get_prefix_type to determine the prefix type. 
  Then, it extracts the prefix based on the type's characteristic 
  given in the problem's description. 
  The complexities for extractions are O(n), O(1) and O(1) for fixed, mobile and telemarket,
  respectively. In mobile and telemarket types, we have fixed access. In fixed type, we have
  a search for ")" which is O(n). Then, we have slice access which depends on the index of ")", which is O(k). 
  Therefore, the function's complexity is O(n).


- For functions get_prefix_type and get_mobile_prefix, the numbers can be assumed to be fixed in length. 
  Therefore, even though these functions are O(n) w.r.t number length, the number lengths almost
  never change in length. In every part of the world, it is 10-15 characters long.
  Therefore, the complexities of these functions reduce to O(1),
  considering the input of our problem, which is the rows of our records.

-- All in all, Line 106 is O(n), Line 107 is O(n) and Line 108 is O(n log n) as it uses timsort
   in its backend [1]. Complete complexity is O(n logn).

PART B:
- get_indices_of_same_type is O(n) due to a forward pass.
- calc_same_type_percentage is a sequence of O(n), O(n) and O(n) (Line 110-112)
- percetange calculation is O(1)
-- All in all it's O(n).


Task 4
------------
- get_unique is O(n) (See Task 1).
- get_col_unique is a forward pass followed by get_unique, therefore, O(n).
- check_numbers loops lumbers and checks for each number if it is in the given list. Therefore, O(n**2). 
- get_possible_telemarketers is O(n**2) due to the check_numbers. In Lines 46-48, O(n). The rest are 
  constant, i.e irrelevant for the input. 

- All in all, the complexity is O(n**2), which is bad.



References
------------
[1]: https://stackoverflow.com/questions/14434490/what-is-the-complexity-of-the-sorted-function